/* გამოკლების ოპერაცია λ-აღრიცხვაში (λ-calculus)

სასარგებლო მასალა:
    ილიას სახელმწიფო უნივერსიტეტის გამოთვლითი ცენტრი
    https://www.facebook.com/watch/live/?ref=search&v=6591820374222486 (1:17:55)

    Gabriel Lebec - Fullstack Academy
    https://www.youtube.com/watch?v=3VQ382QG-y4
*/


/* შევეცადოთ λ-რიცხვების "შექმნა" მხოლოდ ფუნქციების გამოყენებით.
   შეგვიძლია გამოვიყენოთ მხოლოდ ფუნქციის განმარტება და ფუნქციის გამოძახება.
   არ შეგვიძლია გამოვიყენოთ სხვა არაფერი. მათ შორის:
        სხვა მონაცემთა ტიპები:
            ჩვეულებრივი რიცხვი, ბულიანი, სტრიქონი, და ა.შ.
        ოპერაციები:
            მიმატება, გამოკლება, გამრავლება, გაყოფა, ახარისხება
            ლოგიკური ოპერატორები: "და", "ან"
        ჯავასკრიპტის ჩაშენებული ფუნქციები:
            მაგალითად Math.add()
*/

/*   აი, პირველი რამდენიმე არაუარყოფითი λ-რიცხვის "განმარტება" */
let zero = f => a => a // "λ-რიცხვი ნული" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას "ნულჯერ" ამუშავებს პარამეტრზე
let one = f => a => f(a)  // "λ-რიცხვი ერთი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ერთჯერ ამუშავებს პარამეტრზე
let two = f => a => f(f(a)) // "λ-რიცხვი ორი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ორჯერ ამუშავებს პარამეტრზე
let three = f => a => f(f(f(a))) // "λ-რიცხვი სამი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას სამჯერ ამუშავებს პარამეტრზე
let four = f => a => f(f(f(f(a)))) // "λ-რიცხვი ოთხი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ოთხჯერ ამუშავებს პარამეტრზე
let five = f => a => f(f(f(f(f(a))))) // "λ-რიცხვი ხუთი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ხუთჯერ ამუშავებს პარამეტრზე


/* საქმის გაგრძელება რომ გავამარტივოთ, გამოვიგონოთ "მომდევნო" ოპერატორი.
   ცხადია, ეს იქნება ფუნქცია. ეს ფუნქცია პარამეტრად აიღებს ჩვენს "λ-რიცხვს" და დააბრუნებს "მომდევნო λ-რიცხვს" */

let NEXT = n => f => a => f(n(f)(a))

/* ეხლა შეგვიძლია გავაგრძელოთ λ-რიცხვების რეკურსიული განმარტება */

let six = NEXT(five)
let seven = NEXT(six)
let eight = NEXT(seven)
let nine = NEXT(eight)
let ten = NEXT(nine)


/* ვცადოთ შევამოწმოთ, თუ იქცევა ჩვენი "λ-რიცხვები" სწორად.
   მხოლოდ შემოწმებისთვის ჩვენ დავარღვევთ წესებს და გამოვიყენებთ სტრიქონებს. მაგრამ ეს იქნება მხოლოდ შემოწმებისთვის.
   მოდით, შევქმნათ სატესტო ფუნქცია addBall, რომელიც აიღებს სტრიქონს და დამატებს ბურთის სიმბოლოს: ⚽
*/
let addBall = s => s + '⚽'

/* მოდი, შევამოწმოთ ჩვენი "λ-რიცხვი შვიდი".
   ამისთვის, "შვიდს" გადავცეთ ჯერ ჩვენი ფუნქცია addBall, და მერე სტრიქონი 'ტესტი'
   მაშინ, "შვიდმა" ჩვენი ფუნქცია შვიდჯერ უნდა ამუშავოს საწყის სტრიქონზე 'ტესტი'
   თუ "λ-რიცხვი შვიდი" სწორად მუშაობს, შედეგად უნდა მივიღოთ 'ტესტი⚽⚽⚽⚽⚽⚽⚽' (სიტყვა "ტესტი" შვიდი ბურთით)
*/
seven(addBall)('ტესტი') // გვაძლევს სწორ შედეგს: 'ტესტი⚽⚽⚽⚽⚽⚽⚽'

/* ეხლა "შევქმნათ" შეკრების ოპერაცია.
   შეკრების ოპერატორიც იქნება ფუნქცია, რომელიც აიღებს ჯერ ერთ "λ-რიცხვს", მერე მეორე "λ-რიცხვს", და დააბრუნებს ახალ "λ-რიცხვს",
   რომელიც იქნება პირველი ორი λ-რიცხვის "ჯამი"
*/

let ADD = n => m => f => a => n(f)(m(f)(a))

/* ეხლა გამოვიყენოთ ჩვენი "შეკრება" და შევქმნათ კიდევ რამდენიმე რიცხვი */
let eleven = ADD(ten)(one)
let twelve = ADD(six)(six)
let thirteen = ADD(nine)(four)
let fourteen = ADD(two)(twelve)
let fiveteen = ADD(seven)(eight)

/* შევამოწმოთ ზოგიერთი "λ-რიცხვი" */
twelve(addBall)('ტესტი') // გვაძლევს სწორ შედეგს: 'ტესტი⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽'
fiveteen(addBall)('ტესტი') // გვაძლევს სწორ შედეგს: 'ტესტი⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽'
