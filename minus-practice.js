/* გამოკლების ოპერაცია λ-აღრიცხვაში (λ-calculus)

სასარგებლო მასალა:
    ილიას სახელმწიფო უნივერსიტეტის გამოთვლითი ცენტრი
    https://www.facebook.com/watch/live/?ref=search&v=6591820374222486 (1:17:55)

    Gabriel Lebec - Fullstack Academy
    https://www.youtube.com/watch?v=3VQ382QG-y4
*/


/* შევეცადოთ რიცხვების "შექმნა" მხოლოდ ფუნქციების გამოყენებით.
   შეგვიძლია გამოვიყენოთ მხოლოდ ფუნქციის განმარტება და ფუნქციის გამოძახება.
   არ შეგვიძლია გამოვიყენოთ სხვა არაფერი. მათ შორის:
        სხვა მონაცემთა ტიპები:
            ჩვეულებრივი რიცხვი, ბულიანი, სტრიქონი, და ა.შ.
        ოპერაციები:
            მიმატება, გამოკლება, გამრავლება, გაყოფა, ახარისხება
            ლოგიკური ოპერატორები: "და", "ან"
        ჯავასკრიპტის ჩაშენებული ფუნქციები:
            მაგალითად Math.add()
*/

/*   აი, პირველი რამდენიმე არაუარყოფითი რიცხვის "განმარტება" */
let zero = f => a => a // "რიცხვი ნული" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას "ნულჯერ" ამუშავებს პარამეტრზე
let one = f => a => f(a)  // "რიცხვი ერთი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ერთჯერ ამუშავებს პარამეტრზე
let two = f => a => f(f(a)) // "რიცხვი ორი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ორჯერ ამუშავებს პარამეტრზე
let three = f => a => f(f(f(a))) // "რიცხვი სამი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას სამჯერ ამუშავებს პარამეტრზე
let four = f => a => f(f(f(f(a)))) // "რიცხვი ოთხი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ოთხჯერ ამუშავებს პარამეტრზე
let five = f => a => f(f(f(f(f(a))))) // "რიცხვი ხუთი" იღებს ფუნქციას, მერე პარამეტრს და ფუნქციას ხუთჯერ ამუშავებს პარამეტრზე


/* საქმის გაგრძელება რომ გავამარტივოთ, გამოვიგონოთ "მომდევნო" ოპერატორი.
   ცხადია, ეს იქნება ფუნქცია. ეს ფუნქცია პარამეტრად აიღებს ჩვენს "რიცხვს" და დააბრუნებს "მომდევნო რიცხვს" */

let NEXT = n => f => a => f(n(f)(a))

/* ეხლა შეგვიძლია გავაგრძელოთ რიცხვების რეკურსიული განმარტება */

let six = NEXT(five)
let seven = NEXT(six)
let eight = NEXT(seven)
let nine = NEXT(eight)
let ten = NEXT(nine)


/* ვცადოთ შევამოწმოთ, თუ იქცევა ჩვენი "რიცხვები" სწორად.
   მხოლოდ შემოწმებისთვის ჩვენ დავარღვევთ წესებს და გამოვიყენებთ სტრიქონებს. მაგრამ ეს იქნება მხოლოდ შემოწმებისთვის.
   მოდით, შევქმნათ სატესტო ფუნქცია addBall, რომელიც აიღებს სტრიქონს და დამატებს ბურთის სიმბოლოს: ⚽
*/
let addBall = s => s + '⚽'

/* მოდი, შევამოწმოთ ჩვენი "რიცხვი შვიდი".
   ამისთვის, "შვიდს" გადავცეთ ჯერ ჩვენი ფუნქცია addBall, და მერე სტრიქონი 'ტესტი'
   მაშინ, "შვიდმა" ჩვენი ფუნქცია შვიდჯერ უნდა ამუშავოს საწყის სტრიქონზე 'ტესტი'
   თუ "რიცხვი შვიდი" სწორად მუშაობს, შედეგად უნდა მივიღოთ 'ტესტი⚽⚽⚽⚽⚽⚽⚽' (სიტყვა "ტესტი" შვიდი ბურთით)
*/
seven(addBall)('ტესტი') // გვაძლევს სწორ შედეგს: 'ტესტი⚽⚽⚽⚽⚽⚽⚽'

/* ეხლა "შევქმნათ" შეკრების ოპერაცია.
   შეკრების ოპერატორიც იქნება ფუნქცია, რომელიც აიღებს ჯერ ერთ "რიცხვს", მერე მეორე "რიცხვს", და დააბრუნებს "რიცხვს",
   რომელიც იქნება პირველი ორი რიცხვის "ჯამი"
*/

let ADD = n => m => f => a => n(f)(m(f)(a))

/* ეხლა გამოვიყენოთ ჩვენი "შეკრება" და შევქმნათ კიდევ რამდენიმე რიცხვი */
let eleven = ADD(ten)(one)
let twelve = ADD(six)(six)
let thirteen = ADD(nine)(four)
let fourteen = ADD(two)(twelve)
let fiveteen = ADD(seven)(eight)

/* შევამოწმოთ ზოგიერთი "რიცხვი" */
twelve(addBall)('ტესტი') // გვაძლევს სწორ შედეგს: 'ტესტი⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽'
fiveteen(addBall)('ტესტი') // გვაძლევს სწორ შედეგს: 'ტესტი⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽⚽'
